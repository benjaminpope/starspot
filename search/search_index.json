{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"starspot","text":"<p>starspot is a tool for measuring stellar rotation periods using Lomb-Scargle (LS) periodograms, autocorrelation functions (ACFs), phase dispersion minimization (PDM) and Gaussian processes (GPs).</p> <p>starspot is compatible with any light curve with time, flux and flux uncertainty measurements, including Kepler, K2 and TESS light curves. If your light curve is has evenly-spaced (or close to evenly-spaced) observations, all three of these methods: LS periodograms, ACFs and GPs will be applicable. For unevenly spaced light curves like those from Gaia, or ground-based observatories, LS periodograms and GPs are preferable to ACFs.</p> <p>For example usage, see the tutorial notebook.</p>"},{"location":"#license-attribution","title":"License &amp; attribution","text":"<p>Copyright 2018, Ruth Angus. Updates to Jax by Benjamin Pope.</p> <p>starspot uses the astropy implementation of Lomb-Scargle periodograms and the tinygp implementation of fast celerite Gaussian processes.</p> <p>The source code is made available under the terms of the MIT license.</p> <p>If you make use of this code, please cite this package, its dependencies, and the associated paper </p> <pre><code>@ARTICLE{Angus2018,\n       author = {{Angus}, Ruth and {Morton}, Timothy and {Aigrain}, Suzanne and {Foreman-Mackey}, Daniel and {Rajpaul}, Vinesh},\n        title = \"{Inferring probabilistic stellar rotation periods using Gaussian processes}\",\n      journal = {\\mnras},\n     keywords = {methods: data analysis, methods: statistical, techniques: photometric, stars: rotation, stars: solar-type, starspots, Astrophysics - Solar and Stellar Astrophysics, Astrophysics - Instrumentation and Methods for Astrophysics},\n         year = 2018,\n        month = feb,\n       volume = {474},\n       number = {2},\n        pages = {2094-2108},\n          doi = {10.1093/mnras/stx2109},\narchivePrefix = {arXiv},\n       eprint = {1706.05459},\n primaryClass = {astro-ph.SR},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2018MNRAS.474.2094A},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n</code></pre>"},{"location":"starspot_api/","title":"Documentation for <code>starspot</code>","text":"<p>             Bases: <code>object</code></p> <p>Code for measuring stellar rotation periods.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>array</code> <p>The time array in days.</p> required <code>flux</code> <code>array</code> <p>The flux array.</p> required <code>flux_err</code> <code>array</code> <p>The array of flux uncertainties.</p> required Source code in <code>starspot/starspot.py</code> <pre><code>class RotationModel(object):\n\"\"\"\n    Code for measuring stellar rotation periods.\n\n    Args:\n        time (array): The time array in days.\n        flux (array): The flux array.\n        flux_err (array): The array of flux uncertainties.\n    \"\"\"\n\n    def __init__(self, time, flux, flux_err):\n        self.time = time\n        self.flux = flux\n        self.flux_err = flux_err\n        self.Rvar = np.percentile(flux, 95) - np.percentile(flux, 5)\n\n    # def calc_Rvar(self):\n    #     Rvar = np.percentile(self.flux, 95) - np.percentile(self.flux, 5)\n    #     self.Rvar = Rvar\n    #     return Rvar\n\n    def lc_plot(self):\n\"\"\"\n        Plot the light curve.\n        \"\"\"\n        plt.figure(figsize=(20, 5))\n        plt.plot(self.time, self.flux, \"k.\", ms=.5);\n        plt.xlabel(\"Time [days]\")\n        plt.ylabel(\"Relative Flux\");\n        plt.subplots_adjust(bottom=.2)\n\n    def ls_rotation(self, high_pass=False, min_period=.5, max_period=50.,\n                    samples_per_peak=50, input_freq=None, input_power=None,\n                    input_ls_period=None):\n        # filter_period=None, order=3,\n\"\"\"\n        Measure a rotation period using a Lomb-Scargle periodogram.\n\n        Args:\n            min_period (Optional[float]): The minimum rotation period you'd\n                like to search for. The default is 0.5 days since most stars\n                rotate more slowly than this.\n            max_period (Optional[float]): The maximum rotation period you'd\n                like to search for. For Kepler this could be as high as 70\n                days but for K2 it should probably be more like 20-25 days\n                and 10-15 days for TESS. Default is 50.\n            samples_per_peak (Optional[int]): The number of samples per peak.\n\n        Returns:\n            ls_period (float): The Lomb-Scargle rotation period.\n\n        \"\"\"\n        if input_freq is not None and input_power is not None:\n            self.freq = input_freq\n            self.power = input_power\n        else:\n            self.freq = np.linspace(1./max_period, 1./min_period, 100000)\n\n        if input_ls_period is not None:\n            self.ls_period = input_ls_period\n            return input_ls_period\n\n        assert len(self.flux) == sum(np.isfinite(self.flux)), \"Remove NaNs\" \\\n            \" from your flux array before trying to compute a periodogram.\"\n\n        self.power = apt.LombScargle(\n            self.time, self.flux).power(self.freq)\n\n        ps = 1./self.freq\n        peaks = np.array([i for i in range(1, len(ps)-1) if self.power[i-1] &lt;\n                          self.power[i] and self.power[i+1] &lt; self.power[i]])\n\n        if len(peaks) == 0:\n            self.ls_period = 0\n        else:\n            self.ls_period = ps[self.power == max(self.power[peaks])][0]\n        return self.ls_period\n\n\n    def ls_plot(self):\n\"\"\"\n        Make a plot of the periodogram.\n\n        \"\"\"\n\n        fig = plt.figure(figsize=(16, 9))\n        plt.plot(-np.log10(self.freq), self.power, \"k\", zorder=0)\n        plt.axvline(np.log10(self.ls_period), color=\"C1\", lw=4, alpha=0.5,\n                    zorder=1)\n        plt.xlim((-np.log10(self.freq)).min(), (-np.log10(self.freq)).max())\n        plt.yticks([])\n        plt.xlabel(\"log10(Period [days])\")\n        plt.ylabel(\"Power\");\n        plt.subplots_adjust(left=.15, bottom=.15)\n        return fig\n\n    def acf_rotation(self, interval, smooth=9, cutoff=0, window_length=99,\n                     polyorder=3):\n\"\"\"\n        Calculate a rotation period based on an autocorrelation function.\n\n        Args:\n            interval (float): The time in days between observations. For\n                Kepler/K2 long cadence this is 0.02043365, for Tess its about\n                0.00138889 days. Use interval = \"TESS\" or \"Kepler\" for these.\n            smooth (Optional[float]): The smoothing window in days.\n            cutoff (Optional[float]): The number of days to cut off at the\n                beginning.\n            window_length (Optional[float]): The filter window length.\n            polyorder (Optional[float]): The polynomial order of the filter.\n\n        Returns:\n            acf_period (float): The ACF rotation period in days.\n\n        \"\"\"\n        if interval == \"TESS\":\n            interval = 0.00138889\n        if interval == \"Kepler\":\n            interval = 0.02043365\n\n        lags, acf, _x, _y = simple_acf(self.time, self.flux, interval,\n                                       smooth=smooth,\n                                       window_length=window_length,\n                                       polyorder=polyorder)\n\n        self.acf_x = _x\n        self.acf_y = _y\n\n        # find all the peaks\n        m = lags &gt; cutoff\n        xpeaks, ypeaks = get_peak_statistics(lags[m], acf[m],\n                                             sort_by=\"height\")\n\n        self.lags = lags[m]\n        self.acf = acf[m]\n        self.acf_period = xpeaks[0]\n        return xpeaks[0]\n\n    def acf_plot(self):\n\"\"\"\n        Make a plot of the autocorrelation function.\n\n        \"\"\"\n        fig = plt.figure(figsize=(16, 9))\n        plt.plot(self.lags, self.acf, \"k\")\n        plt.axvline(self.acf_period, color=\"C1\")\n        plt.xlabel(\"Period [days]\")\n        plt.ylabel(\"Correlation\")\n        plt.xlim(0, max(self.lags))\n        plt.subplots_adjust(left=.15, bottom=.15)\n        return fig\n\n    def pdm_rotation(self, period_grid, pdm_nbins=10):\n\"\"\"\n        Calculate the optimum period from phase dispersion minimization.\n\n        Args:\n            period_grid (array): The period grid.\n            pdm_nbins (array): The number of bins to use when calculating phase\n                dispersion.\n\n        Returns:\n            phis (array): The array of phi statistics\n\n        \"\"\"\n        self.pdm_nbins = pdm_nbins\n        self.period_grid = period_grid\n\n        nperiods = len(period_grid)\n        phis = np.zeros(nperiods)\n        # for i, p in enumerate(period_grid):\n        for i in trange(len(period_grid)):\n            phis[i] = phi(pdm_nbins, period_grid[i], self.time, self.flux)\n\n        self.phis = phis\n\n        # Find period with the lowest Phi\n        ind = np.argmin(phis)\n        self.pdm_period = period_grid[ind]\n        if hasattr(self.pdm_period, 'len'):\n            self.pdm_period = self.pdm_period[0]\n\n        # Estimate the uncertainty\n        err, mu, a, b = estimate_uncertainty(period_grid, phis,\n                                               period_grid[ind])\n        self.sigma = err\n        self.mu = mu\n        self.a = a\n        self.b = b\n        self.period_err = err\n\n        # Calculate phase (for plotting)\n        phase = calc_phase(self.pdm_period, self.time)\n        self.phase = phase\n\n        return self.pdm_period, err\n\n    def pdm_plot(self):\n\"\"\"\n        Make a plot of the phase dispersion function.\n\n        \"\"\"\n        # Calculate phase, etc.\n        x_means, phase_bs, Ns, sj2s, xb, pb = \\\n            phase_bins(self.pdm_nbins, self.phase, self.flux)\n        mid_phase_bins = np.diff(phase_bs)*.5 + phase_bs[:-1]\n\n        fig = plt.figure(figsize=(16, 9), dpi=200)\n        ax1 = fig.add_subplot(311)\n        ax1.plot(self.time, self.flux, \"k.\", ms=1, alpha=.5)\n        ax1.set_xlabel(\"Time\")\n        ax1.set_ylabel(\"Flux\")\n\n        ax2 = fig.add_subplot(312)\n        ax2.plot(self.phase, self.flux, \"k.\", alpha=.1)\n        # ax2.errorbar(mid_phase_bins, x_means, yerr=sj2s, fmt=\".\")\n        ax2.set_xlabel(\"Phase\")\n        ax2.set_ylabel(\"Flux\")\n\n        ax3 = fig.add_subplot(313)\n        ax3.plot(self.period_grid, gaussian([self.a, self.b, self.mu,\n                                             self.sigma], self.period_grid))\n        ax3.plot(self.period_grid, self.phis, \"k\")\n        ax3.set_xlabel(\"Period [days]\")\n        ax3.set_ylabel(\"Dispersion\")\n        ax3.axvline(self.pdm_period, color=\".5\", ls=\"--\")\n        ax3.axvline(self.mu, color=\"C0\", ls=\"--\")\n        ax3.axvline(self.mu - self.sigma, ls=\"--\", lw=.5)\n        ax3.axvline(self.mu + self.sigma, ls=\"--\", lw=.5)\n        plt.tight_layout()\n        return fig\n\n    def big_plot(self, methods, xlim=None, method_xlim=(0, 50)):\n\"\"\"\n        Make a plot of LS periodogram, ACF and PDM, combined. These things\n        must be precomputed.\n\n        Args:\n            methods (list): A list of period measurement methods to plot. For\n                example, [\"pdm\", \"ls\", \"acf\"], or [\"ls\", \"pdm\"].\n            xlim (Optional[tuple]): The xlim for the light curve panel.\n            method_xlim (Optional[tuple]): The xlim for the methods panel.\n                Default is 0-50 days.\n\n        Returns:\n            The figure object.\n\n        \"\"\"\n        methods = np.array(methods)\n        nmethods = len(methods)\n\n        # Assemble indices selecting methods to plot.\n        inds, i_s, names = np.arange(3), [], np.array([\"pdm\", \"ls\", \"acf\"])\n        for i in range(nmethods):\n            mask = methods[i] == names\n            i_s.append(int(inds[mask]))\n        i_s = np.array(i_s)\n\n        outer = gridspec.GridSpec(3, nmethods,\n                                  height_ratios=[1, 1, nmethods])\n\n        # The light curve panel\n        # --------------------------------------------------------------------\n        gs0 = gridspec.GridSpecFromSubplotSpec(1, 1, subplot_spec=outer[0, :])\n\n        fig = plt.figure(figsize=(16, 16), dpi=200)\n        ax1 = fig.add_subplot(gs0[0, :])\n        # ax1.plot(self.time, self.flux, \"k\", lw=.5, rasterized=True)\n        # ax1.errorbar(self.time, self.flux, yerr=self.flux_err,\n                     # fmt=\"k.\", alpha=.1, rasterized=True)\n        ax1.plot(self.time, self.flux, \"k.\", alpha=.3, mec=\"none\",\n                 rasterized=True)\n        ax1.set_xlabel(\"$\\mathrm{Time~[days]}$\")\n        ax1.set_ylabel(\"$\\mathrm{Normalized~Flux}$\")\n        if xlim is not None:\n            ax1.set_xlim(xlim)\n\n        pdm_tit, ls_tit, acf_tit = \"\", \"\", \"\"\n        if np.any(i_s == 0):\n            pdm_tit = \"PDM = {0:.2f} +/- {1:.2f} days.\".format(self.pdm_period,\n                                                              self.period_err)\n            pdm_x, pdm_y, pdm_p = self.period_grid, self.phis, self.pdm_period\n            err, pdm_phase =  self.period_err, self.phase\n        else:\n            pdm_x, pdm_y, pdm_p, err, pdm_phase = None, None, None, None, None\n        if np.any(i_s == 1):\n            ls_tit = \" LS = {0:.2f} days.\".format(self.ls_period)\n            ls_x, ls_y, ls_p = 1./self.freq, self.power, self.ls_period\n            ls_phase = calc_phase(self.ls_period, self.time)\n        else:\n            ls_x, ls_y, ls_p, ls_phase = None, None, None, None\n        if np.any(i_s == 2):\n            acf_tit = \" ACF = {0:.2f} days.\".format(self.acf_period)\n            acf_x, acf_y, acf_p = self.lags, self.acf, self.acf_period\n            acf_phase = calc_phase(self.acf_period, self.time)\n        else:\n            acf_x, acf_y, acf_p, acf_phase = None, None, None, None\n\n        plt.title(\"{0}{1}{2}\".format(pdm_tit, ls_tit, acf_tit), fontsize=20)\n\n        # The phase-fold panel\n        # --------------------------------------------------------------------\n        gs1 = gridspec.GridSpecFromSubplotSpec(1, nmethods,\n                                               subplot_spec=outer[1, :],\n                                               wspace=0)\n\n        xs = [pdm_phase, ls_phase, acf_phase]\n        xlabels = [\"$\\mathrm{PDM~Phase}$\", \"$\\mathrm{LS~Phase}$\",\n                   \"$\\mathrm{ACF~Phase}$\"]\n\n        colors = [\"k\", \"C0\", \"C1\"]\n        def phase_subplot(x, y, i, xlabel):\n            ax = fig.add_subplot(gs1[0, i])\n            ax.plot(x, y, \".\", color=colors[i], alpha=.1, rasterized=True)\n            ax.set_xlabel(xlabel)\n            ax.set_xlim(0, 1)\n            return ax\n\n        # Plot the panels\n        axs = []\n        for j in range(nmethods):\n            ax = phase_subplot(xs[i_s[j]], self.flux, j, xlabels[i_s[j]])\n            axs.append(ax)\n            if j &gt; 0:\n                plt.setp(ax.get_yticklabels(), visible=False)\n        ax0 = axs[0]\n        ax0.set_ylabel(\"$\\mathrm{Normalized~Flux}$\")\n\n        # The method panel\n        # --------------------------------------------------------------------\n        gs2 = gridspec.GridSpecFromSubplotSpec(nmethods, 1,\n                                               subplot_spec=outer[2, :],\n                                               hspace=0)\n\n        mxs = [pdm_x, ls_x, acf_x]\n        mys = [pdm_y, ls_y, acf_y]\n        ps = [pdm_p, ls_p, acf_p]\n        ylabels = [\"$\\mathrm{Relative~Dispersion}$\", \"$\\mathrm{LS-Power}$\",\n                   \"$\\mathrm{Autocorrelation}$\"]\n\n        def method_subplot(i, x, y, p, ylabel, sharex):\n            if i == 0:\n                ax = fig.add_subplot(gs2[i, :])\n            else:\n                ax = fig.add_subplot(gs2[i, :], sharex=sharex)\n            ax.plot(x, y, \"k\", rasterized=True)\n            ax.axvline(p)\n            ax.axvline(p/2., ls=\"--\")\n            ax.axvline(p*2., ls=\"--\")\n            ax.set_ylabel(ylabel)\n            if method_xlim is not None:\n                ax.set_xlim(method_xlim)\n            return ax\n\n        maxs = []\n        for j in range(nmethods):\n            sharex = ax\n            ax = method_subplot(j, mxs[i_s[j]], mys[i_s[j]], ps[i_s[j]],\n                                ylabels[i_s[j]], sharex)\n            maxs.append(ax)\n            if nmethods &gt; 1 and j &lt; nmethods-1:\n                plt.setp(ax.get_xticklabels(), visible=False)\n\n\n        # Plot a Gaussian on top of PDM plot\n        axloc_ind = np.arange(len(maxs))[np.array(i_s) == 0]\n        if np.any(i_s == 0):\n            ax3 = maxs[int(axloc_ind)]\n            ax3.plot(self.period_grid, gaussian([self.a, self.b, self.mu,\n                                             self.sigma], self.period_grid),\n                     rasterized=True)\n\n        ax5 = maxs[-1]\n        ax5.set_xlabel(\"$\\mathrm{Time~[days]}$\")\n        plt.subplots_adjust(hspace=.1)\n        plt.tight_layout()\n        return fig\n\n    def gp_rotation(self, init_period=None, tune=2000, draws=2000,\n                    prediction=True, cores=None):\n\"\"\"\n        Calculate a rotation period using a Gaussian process method.\n\n        Args:\n            init_period (Optional[float]): Your initial guess for the rotation\n                period. The default is the Lomb-Scargle period.\n            tune (Optional[int]): The number of tuning samples. Default is\n                2000.\n            draws (Optional[int]): The number of samples. Default is 2000.\n            prediction (Optional[Bool]): If true, a prediction will be\n                calculated for each sample. This is useful for plotting the\n                prediction but will slow down the whole calculation.\n        \"\"\"\n        self.prediction = prediction\n\n        t = jnp.array(self.time, dtype=float)\n        dt = jnp.median(jnp.diff(t))\n        t_fine = jnp.linspace(t.min()-dt*5, t.max()+dt*5, np.max([1000, len(t)*10]))\n        # Median of data must be zero\n        y = jnp.array(self.flux, dtype=float) - jnp.median(self.flux)\n        yerr = jnp.array(self.flux_err, dtype=float)\n\n        if init_period is None:\n            # Calculate ls period\n            init_period = self.ls_rotation()\n\n\n        def numpyro_model(t, yerr, y=None):\n            # The mean flux of the time series\n            mean = numpyro.sample(\"mean\", dist.Normal(0.0, 10.0))\n\n            # A jitter term describing excess white noise\n            log_jitter = numpyro.sample(\"log_jitter\", dist.Normal(2*jnp.log(jnp.min(yerr)), 5.0))\n\n            # The parameters of the RotationTerm kernel\n            log_sigma = numpyro.sample(\"log_sigma\", dist.Normal(jnp.log(jnp.var(y)), 5.0))\n            log_period = numpyro.sample(\"log_period\", dist.Normal(jnp.log(init_period), 5.0))\n            log_Q0 = numpyro.sample(\"log_Q0\", dist.Normal(1.0, 10.0))\n            log_deltaQ = numpyro.sample(\"log_deltaQ\", dist.Normal(2.0, 10.0))\n            mix = numpyro.sample(\"mix\", dist.Uniform(0, 1.0))\n\n            # Track the period as a deterministic\n            period = numpyro.deterministic(\"period\",jnp.exp(log_period))\n            params = {'log_sigma': log_sigma, 'log_period': log_period, 'log_Q0': log_Q0,\n                        'log_deltaQ': log_deltaQ, 'log_f': mix, \n                        'mean': mean, 'log_jitter': log_jitter}\n            # sigma, period, Q0, dQ, f = jnp.exp(params['log_sigma'], params['log_period'], \n            #                            params['log_Q0'], params['log_deltaQ'], params['log_f'])\n\n            gp = build_gp(params,t,yerr)\n            numpyro.sample(\"gp\", gp.numpyro_dist(), obs=y)\n\n            if self.prediction:\n                if y is not None:\n                    numpyro.deterministic(\"pred\", gp.condition(y, t_fine).gp.loc)\n\n\n        print(\"Sampling\")\n        nuts_kernel = NUTS(numpyro_model, dense_mass=True, target_accept_prob=0.9)\n        mcmc = MCMC(\n            nuts_kernel,\n            num_warmup=tune,\n            num_samples=draws,\n            num_chains=2,\n            progress_bar=True,\n        )\n        rng_key = jax.random.PRNGKey(34923)\n\n        mcmc.run(rng_key, t, yerr, y=y)\n        samples = mcmc.get_samples()\n\n        # Save samples\n        self.samples = samples\n        self.pred = samples[\"pred\"]\n\n        self.period_samples = samples[\"period\"]\n        self.gp_period = np.median(self.period_samples)\n        lower = np.percentile(self.period_samples, 16)\n        upper = np.percentile(self.period_samples, 84)\n        self.errm = self.gp_period - lower\n        self.errp = upper - self.gp_period\n\n        print('GP Period: %.3f + %.3f - %.3f' % (self.gp_period, self.errp, self.errm))\n\n        self.logQ = np.median(samples[\"log_Q0\"])\n        upperQ = np.percentile(samples[\"log_Q0\"], 84)\n        lowerQ = np.percentile(samples[\"log_Q0\"], 16)\n        self.Qerrp = upperQ - self.logQ\n        self.Qerrm = self.logQ - lowerQ\n        self.t_fine = t_fine\n\n    def plot_prediction(self):\n\"\"\"\n        Plot the GP prediction, fit to the data.\n\n        \"\"\"\n        if not self.prediction:\n            print(\"You must run GP_rotate with prediction=True in order\" \\\n                    \" to plot the prediction.\")\n            return\n\n        fig = plt.figure(figsize=(20, 5))\n        indices = np.random.choice(self.samples['pred'].shape[0],size=100,replace=False)\n\n        plt.errorbar(self.time,self.flux,yerr=self.flux_err,linestyle='none',marker='.',color='k')\n\n        for index in indices:\n            plt.plot(self.t_fine,self.samples['pred'][index,:],alpha=0.1,color='C0')\n        plt.xlabel(\"Time [days]\")\n        plt.ylabel(\"Relative flux\")\n        plt.xlim(self.t_fine.min(),self.t_fine.max())\n        return fig \n\n    def plot_posterior(self,truth=None):\n\"\"\"\n        Plot the posterior probability density function for rotation period.\n        \"\"\"\n        fig = plt.figure(figsize=(20, 5))\n        c= ChainConsumer()\n        c.add_chain([self.samples[key] for key in ['log_Q0', 'period', 'log_sigma', 'log_deltaQ', 'log_jitter', 'mean', 'mix']], \n        parameters=['log_Q0', 'period', 'log_sigma', 'log_deltaQ', 'log_jitter', 'mean', 'mix'], name = 'HMC only')\n        c.plotter.plot(truth=truth)\n        plt.show()\n        return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.acf_plot","title":"<code>acf_plot()</code>","text":"<p>Make a plot of the autocorrelation function.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def acf_plot(self):\n\"\"\"\n    Make a plot of the autocorrelation function.\n\n    \"\"\"\n    fig = plt.figure(figsize=(16, 9))\n    plt.plot(self.lags, self.acf, \"k\")\n    plt.axvline(self.acf_period, color=\"C1\")\n    plt.xlabel(\"Period [days]\")\n    plt.ylabel(\"Correlation\")\n    plt.xlim(0, max(self.lags))\n    plt.subplots_adjust(left=.15, bottom=.15)\n    return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.acf_rotation","title":"<code>acf_rotation(interval, smooth=9, cutoff=0, window_length=99, polyorder=3)</code>","text":"<p>Calculate a rotation period based on an autocorrelation function.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>The time in days between observations. For Kepler/K2 long cadence this is 0.02043365, for Tess its about 0.00138889 days. Use interval = \"TESS\" or \"Kepler\" for these.</p> required <code>smooth</code> <code>Optional[float]</code> <p>The smoothing window in days.</p> <code>9</code> <code>cutoff</code> <code>Optional[float]</code> <p>The number of days to cut off at the beginning.</p> <code>0</code> <code>window_length</code> <code>Optional[float]</code> <p>The filter window length.</p> <code>99</code> <code>polyorder</code> <code>Optional[float]</code> <p>The polynomial order of the filter.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>acf_period</code> <code>float</code> <p>The ACF rotation period in days.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def acf_rotation(self, interval, smooth=9, cutoff=0, window_length=99,\n                 polyorder=3):\n\"\"\"\n    Calculate a rotation period based on an autocorrelation function.\n\n    Args:\n        interval (float): The time in days between observations. For\n            Kepler/K2 long cadence this is 0.02043365, for Tess its about\n            0.00138889 days. Use interval = \"TESS\" or \"Kepler\" for these.\n        smooth (Optional[float]): The smoothing window in days.\n        cutoff (Optional[float]): The number of days to cut off at the\n            beginning.\n        window_length (Optional[float]): The filter window length.\n        polyorder (Optional[float]): The polynomial order of the filter.\n\n    Returns:\n        acf_period (float): The ACF rotation period in days.\n\n    \"\"\"\n    if interval == \"TESS\":\n        interval = 0.00138889\n    if interval == \"Kepler\":\n        interval = 0.02043365\n\n    lags, acf, _x, _y = simple_acf(self.time, self.flux, interval,\n                                   smooth=smooth,\n                                   window_length=window_length,\n                                   polyorder=polyorder)\n\n    self.acf_x = _x\n    self.acf_y = _y\n\n    # find all the peaks\n    m = lags &gt; cutoff\n    xpeaks, ypeaks = get_peak_statistics(lags[m], acf[m],\n                                         sort_by=\"height\")\n\n    self.lags = lags[m]\n    self.acf = acf[m]\n    self.acf_period = xpeaks[0]\n    return xpeaks[0]\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.big_plot","title":"<code>big_plot(methods, xlim=None, method_xlim=(0, 50))</code>","text":"<p>Make a plot of LS periodogram, ACF and PDM, combined. These things must be precomputed.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>list</code> <p>A list of period measurement methods to plot. For example, [\"pdm\", \"ls\", \"acf\"], or [\"ls\", \"pdm\"].</p> required <code>xlim</code> <code>Optional[tuple]</code> <p>The xlim for the light curve panel.</p> <code>None</code> <code>method_xlim</code> <code>Optional[tuple]</code> <p>The xlim for the methods panel. Default is 0-50 days.</p> <code>(0, 50)</code> <p>Returns:</p> Type Description <p>The figure object.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def big_plot(self, methods, xlim=None, method_xlim=(0, 50)):\n\"\"\"\n    Make a plot of LS periodogram, ACF and PDM, combined. These things\n    must be precomputed.\n\n    Args:\n        methods (list): A list of period measurement methods to plot. For\n            example, [\"pdm\", \"ls\", \"acf\"], or [\"ls\", \"pdm\"].\n        xlim (Optional[tuple]): The xlim for the light curve panel.\n        method_xlim (Optional[tuple]): The xlim for the methods panel.\n            Default is 0-50 days.\n\n    Returns:\n        The figure object.\n\n    \"\"\"\n    methods = np.array(methods)\n    nmethods = len(methods)\n\n    # Assemble indices selecting methods to plot.\n    inds, i_s, names = np.arange(3), [], np.array([\"pdm\", \"ls\", \"acf\"])\n    for i in range(nmethods):\n        mask = methods[i] == names\n        i_s.append(int(inds[mask]))\n    i_s = np.array(i_s)\n\n    outer = gridspec.GridSpec(3, nmethods,\n                              height_ratios=[1, 1, nmethods])\n\n    # The light curve panel\n    # --------------------------------------------------------------------\n    gs0 = gridspec.GridSpecFromSubplotSpec(1, 1, subplot_spec=outer[0, :])\n\n    fig = plt.figure(figsize=(16, 16), dpi=200)\n    ax1 = fig.add_subplot(gs0[0, :])\n    # ax1.plot(self.time, self.flux, \"k\", lw=.5, rasterized=True)\n    # ax1.errorbar(self.time, self.flux, yerr=self.flux_err,\n                 # fmt=\"k.\", alpha=.1, rasterized=True)\n    ax1.plot(self.time, self.flux, \"k.\", alpha=.3, mec=\"none\",\n             rasterized=True)\n    ax1.set_xlabel(\"$\\mathrm{Time~[days]}$\")\n    ax1.set_ylabel(\"$\\mathrm{Normalized~Flux}$\")\n    if xlim is not None:\n        ax1.set_xlim(xlim)\n\n    pdm_tit, ls_tit, acf_tit = \"\", \"\", \"\"\n    if np.any(i_s == 0):\n        pdm_tit = \"PDM = {0:.2f} +/- {1:.2f} days.\".format(self.pdm_period,\n                                                          self.period_err)\n        pdm_x, pdm_y, pdm_p = self.period_grid, self.phis, self.pdm_period\n        err, pdm_phase =  self.period_err, self.phase\n    else:\n        pdm_x, pdm_y, pdm_p, err, pdm_phase = None, None, None, None, None\n    if np.any(i_s == 1):\n        ls_tit = \" LS = {0:.2f} days.\".format(self.ls_period)\n        ls_x, ls_y, ls_p = 1./self.freq, self.power, self.ls_period\n        ls_phase = calc_phase(self.ls_period, self.time)\n    else:\n        ls_x, ls_y, ls_p, ls_phase = None, None, None, None\n    if np.any(i_s == 2):\n        acf_tit = \" ACF = {0:.2f} days.\".format(self.acf_period)\n        acf_x, acf_y, acf_p = self.lags, self.acf, self.acf_period\n        acf_phase = calc_phase(self.acf_period, self.time)\n    else:\n        acf_x, acf_y, acf_p, acf_phase = None, None, None, None\n\n    plt.title(\"{0}{1}{2}\".format(pdm_tit, ls_tit, acf_tit), fontsize=20)\n\n    # The phase-fold panel\n    # --------------------------------------------------------------------\n    gs1 = gridspec.GridSpecFromSubplotSpec(1, nmethods,\n                                           subplot_spec=outer[1, :],\n                                           wspace=0)\n\n    xs = [pdm_phase, ls_phase, acf_phase]\n    xlabels = [\"$\\mathrm{PDM~Phase}$\", \"$\\mathrm{LS~Phase}$\",\n               \"$\\mathrm{ACF~Phase}$\"]\n\n    colors = [\"k\", \"C0\", \"C1\"]\n    def phase_subplot(x, y, i, xlabel):\n        ax = fig.add_subplot(gs1[0, i])\n        ax.plot(x, y, \".\", color=colors[i], alpha=.1, rasterized=True)\n        ax.set_xlabel(xlabel)\n        ax.set_xlim(0, 1)\n        return ax\n\n    # Plot the panels\n    axs = []\n    for j in range(nmethods):\n        ax = phase_subplot(xs[i_s[j]], self.flux, j, xlabels[i_s[j]])\n        axs.append(ax)\n        if j &gt; 0:\n            plt.setp(ax.get_yticklabels(), visible=False)\n    ax0 = axs[0]\n    ax0.set_ylabel(\"$\\mathrm{Normalized~Flux}$\")\n\n    # The method panel\n    # --------------------------------------------------------------------\n    gs2 = gridspec.GridSpecFromSubplotSpec(nmethods, 1,\n                                           subplot_spec=outer[2, :],\n                                           hspace=0)\n\n    mxs = [pdm_x, ls_x, acf_x]\n    mys = [pdm_y, ls_y, acf_y]\n    ps = [pdm_p, ls_p, acf_p]\n    ylabels = [\"$\\mathrm{Relative~Dispersion}$\", \"$\\mathrm{LS-Power}$\",\n               \"$\\mathrm{Autocorrelation}$\"]\n\n    def method_subplot(i, x, y, p, ylabel, sharex):\n        if i == 0:\n            ax = fig.add_subplot(gs2[i, :])\n        else:\n            ax = fig.add_subplot(gs2[i, :], sharex=sharex)\n        ax.plot(x, y, \"k\", rasterized=True)\n        ax.axvline(p)\n        ax.axvline(p/2., ls=\"--\")\n        ax.axvline(p*2., ls=\"--\")\n        ax.set_ylabel(ylabel)\n        if method_xlim is not None:\n            ax.set_xlim(method_xlim)\n        return ax\n\n    maxs = []\n    for j in range(nmethods):\n        sharex = ax\n        ax = method_subplot(j, mxs[i_s[j]], mys[i_s[j]], ps[i_s[j]],\n                            ylabels[i_s[j]], sharex)\n        maxs.append(ax)\n        if nmethods &gt; 1 and j &lt; nmethods-1:\n            plt.setp(ax.get_xticklabels(), visible=False)\n\n\n    # Plot a Gaussian on top of PDM plot\n    axloc_ind = np.arange(len(maxs))[np.array(i_s) == 0]\n    if np.any(i_s == 0):\n        ax3 = maxs[int(axloc_ind)]\n        ax3.plot(self.period_grid, gaussian([self.a, self.b, self.mu,\n                                         self.sigma], self.period_grid),\n                 rasterized=True)\n\n    ax5 = maxs[-1]\n    ax5.set_xlabel(\"$\\mathrm{Time~[days]}$\")\n    plt.subplots_adjust(hspace=.1)\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.gp_rotation","title":"<code>gp_rotation(init_period=None, tune=2000, draws=2000, prediction=True, cores=None)</code>","text":"<p>Calculate a rotation period using a Gaussian process method.</p> <p>Parameters:</p> Name Type Description Default <code>init_period</code> <code>Optional[float]</code> <p>Your initial guess for the rotation period. The default is the Lomb-Scargle period.</p> <code>None</code> <code>tune</code> <code>Optional[int]</code> <p>The number of tuning samples. Default is 2000.</p> <code>2000</code> <code>draws</code> <code>Optional[int]</code> <p>The number of samples. Default is 2000.</p> <code>2000</code> <code>prediction</code> <code>Optional[Bool]</code> <p>If true, a prediction will be calculated for each sample. This is useful for plotting the prediction but will slow down the whole calculation.</p> <code>True</code> Source code in <code>starspot/starspot.py</code> <pre><code>def gp_rotation(self, init_period=None, tune=2000, draws=2000,\n                prediction=True, cores=None):\n\"\"\"\n    Calculate a rotation period using a Gaussian process method.\n\n    Args:\n        init_period (Optional[float]): Your initial guess for the rotation\n            period. The default is the Lomb-Scargle period.\n        tune (Optional[int]): The number of tuning samples. Default is\n            2000.\n        draws (Optional[int]): The number of samples. Default is 2000.\n        prediction (Optional[Bool]): If true, a prediction will be\n            calculated for each sample. This is useful for plotting the\n            prediction but will slow down the whole calculation.\n    \"\"\"\n    self.prediction = prediction\n\n    t = jnp.array(self.time, dtype=float)\n    dt = jnp.median(jnp.diff(t))\n    t_fine = jnp.linspace(t.min()-dt*5, t.max()+dt*5, np.max([1000, len(t)*10]))\n    # Median of data must be zero\n    y = jnp.array(self.flux, dtype=float) - jnp.median(self.flux)\n    yerr = jnp.array(self.flux_err, dtype=float)\n\n    if init_period is None:\n        # Calculate ls period\n        init_period = self.ls_rotation()\n\n\n    def numpyro_model(t, yerr, y=None):\n        # The mean flux of the time series\n        mean = numpyro.sample(\"mean\", dist.Normal(0.0, 10.0))\n\n        # A jitter term describing excess white noise\n        log_jitter = numpyro.sample(\"log_jitter\", dist.Normal(2*jnp.log(jnp.min(yerr)), 5.0))\n\n        # The parameters of the RotationTerm kernel\n        log_sigma = numpyro.sample(\"log_sigma\", dist.Normal(jnp.log(jnp.var(y)), 5.0))\n        log_period = numpyro.sample(\"log_period\", dist.Normal(jnp.log(init_period), 5.0))\n        log_Q0 = numpyro.sample(\"log_Q0\", dist.Normal(1.0, 10.0))\n        log_deltaQ = numpyro.sample(\"log_deltaQ\", dist.Normal(2.0, 10.0))\n        mix = numpyro.sample(\"mix\", dist.Uniform(0, 1.0))\n\n        # Track the period as a deterministic\n        period = numpyro.deterministic(\"period\",jnp.exp(log_period))\n        params = {'log_sigma': log_sigma, 'log_period': log_period, 'log_Q0': log_Q0,\n                    'log_deltaQ': log_deltaQ, 'log_f': mix, \n                    'mean': mean, 'log_jitter': log_jitter}\n        # sigma, period, Q0, dQ, f = jnp.exp(params['log_sigma'], params['log_period'], \n        #                            params['log_Q0'], params['log_deltaQ'], params['log_f'])\n\n        gp = build_gp(params,t,yerr)\n        numpyro.sample(\"gp\", gp.numpyro_dist(), obs=y)\n\n        if self.prediction:\n            if y is not None:\n                numpyro.deterministic(\"pred\", gp.condition(y, t_fine).gp.loc)\n\n\n    print(\"Sampling\")\n    nuts_kernel = NUTS(numpyro_model, dense_mass=True, target_accept_prob=0.9)\n    mcmc = MCMC(\n        nuts_kernel,\n        num_warmup=tune,\n        num_samples=draws,\n        num_chains=2,\n        progress_bar=True,\n    )\n    rng_key = jax.random.PRNGKey(34923)\n\n    mcmc.run(rng_key, t, yerr, y=y)\n    samples = mcmc.get_samples()\n\n    # Save samples\n    self.samples = samples\n    self.pred = samples[\"pred\"]\n\n    self.period_samples = samples[\"period\"]\n    self.gp_period = np.median(self.period_samples)\n    lower = np.percentile(self.period_samples, 16)\n    upper = np.percentile(self.period_samples, 84)\n    self.errm = self.gp_period - lower\n    self.errp = upper - self.gp_period\n\n    print('GP Period: %.3f + %.3f - %.3f' % (self.gp_period, self.errp, self.errm))\n\n    self.logQ = np.median(samples[\"log_Q0\"])\n    upperQ = np.percentile(samples[\"log_Q0\"], 84)\n    lowerQ = np.percentile(samples[\"log_Q0\"], 16)\n    self.Qerrp = upperQ - self.logQ\n    self.Qerrm = self.logQ - lowerQ\n    self.t_fine = t_fine\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.lc_plot","title":"<code>lc_plot()</code>","text":"<p>Plot the light curve.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def lc_plot(self):\n\"\"\"\n    Plot the light curve.\n    \"\"\"\n    plt.figure(figsize=(20, 5))\n    plt.plot(self.time, self.flux, \"k.\", ms=.5);\n    plt.xlabel(\"Time [days]\")\n    plt.ylabel(\"Relative Flux\");\n    plt.subplots_adjust(bottom=.2)\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.ls_plot","title":"<code>ls_plot()</code>","text":"<p>Make a plot of the periodogram.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def ls_plot(self):\n\"\"\"\n    Make a plot of the periodogram.\n\n    \"\"\"\n\n    fig = plt.figure(figsize=(16, 9))\n    plt.plot(-np.log10(self.freq), self.power, \"k\", zorder=0)\n    plt.axvline(np.log10(self.ls_period), color=\"C1\", lw=4, alpha=0.5,\n                zorder=1)\n    plt.xlim((-np.log10(self.freq)).min(), (-np.log10(self.freq)).max())\n    plt.yticks([])\n    plt.xlabel(\"log10(Period [days])\")\n    plt.ylabel(\"Power\");\n    plt.subplots_adjust(left=.15, bottom=.15)\n    return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.ls_rotation","title":"<code>ls_rotation(high_pass=False, min_period=0.5, max_period=50.0, samples_per_peak=50, input_freq=None, input_power=None, input_ls_period=None)</code>","text":"<p>Measure a rotation period using a Lomb-Scargle periodogram.</p> <p>Parameters:</p> Name Type Description Default <code>min_period</code> <code>Optional[float]</code> <p>The minimum rotation period you'd like to search for. The default is 0.5 days since most stars rotate more slowly than this.</p> <code>0.5</code> <code>max_period</code> <code>Optional[float]</code> <p>The maximum rotation period you'd like to search for. For Kepler this could be as high as 70 days but for K2 it should probably be more like 20-25 days and 10-15 days for TESS. Default is 50.</p> <code>50.0</code> <code>samples_per_peak</code> <code>Optional[int]</code> <p>The number of samples per peak.</p> <code>50</code> <p>Returns:</p> Name Type Description <code>ls_period</code> <code>float</code> <p>The Lomb-Scargle rotation period.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def ls_rotation(self, high_pass=False, min_period=.5, max_period=50.,\n                samples_per_peak=50, input_freq=None, input_power=None,\n                input_ls_period=None):\n    # filter_period=None, order=3,\n\"\"\"\n    Measure a rotation period using a Lomb-Scargle periodogram.\n\n    Args:\n        min_period (Optional[float]): The minimum rotation period you'd\n            like to search for. The default is 0.5 days since most stars\n            rotate more slowly than this.\n        max_period (Optional[float]): The maximum rotation period you'd\n            like to search for. For Kepler this could be as high as 70\n            days but for K2 it should probably be more like 20-25 days\n            and 10-15 days for TESS. Default is 50.\n        samples_per_peak (Optional[int]): The number of samples per peak.\n\n    Returns:\n        ls_period (float): The Lomb-Scargle rotation period.\n\n    \"\"\"\n    if input_freq is not None and input_power is not None:\n        self.freq = input_freq\n        self.power = input_power\n    else:\n        self.freq = np.linspace(1./max_period, 1./min_period, 100000)\n\n    if input_ls_period is not None:\n        self.ls_period = input_ls_period\n        return input_ls_period\n\n    assert len(self.flux) == sum(np.isfinite(self.flux)), \"Remove NaNs\" \\\n        \" from your flux array before trying to compute a periodogram.\"\n\n    self.power = apt.LombScargle(\n        self.time, self.flux).power(self.freq)\n\n    ps = 1./self.freq\n    peaks = np.array([i for i in range(1, len(ps)-1) if self.power[i-1] &lt;\n                      self.power[i] and self.power[i+1] &lt; self.power[i]])\n\n    if len(peaks) == 0:\n        self.ls_period = 0\n    else:\n        self.ls_period = ps[self.power == max(self.power[peaks])][0]\n    return self.ls_period\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.pdm_plot","title":"<code>pdm_plot()</code>","text":"<p>Make a plot of the phase dispersion function.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def pdm_plot(self):\n\"\"\"\n    Make a plot of the phase dispersion function.\n\n    \"\"\"\n    # Calculate phase, etc.\n    x_means, phase_bs, Ns, sj2s, xb, pb = \\\n        phase_bins(self.pdm_nbins, self.phase, self.flux)\n    mid_phase_bins = np.diff(phase_bs)*.5 + phase_bs[:-1]\n\n    fig = plt.figure(figsize=(16, 9), dpi=200)\n    ax1 = fig.add_subplot(311)\n    ax1.plot(self.time, self.flux, \"k.\", ms=1, alpha=.5)\n    ax1.set_xlabel(\"Time\")\n    ax1.set_ylabel(\"Flux\")\n\n    ax2 = fig.add_subplot(312)\n    ax2.plot(self.phase, self.flux, \"k.\", alpha=.1)\n    # ax2.errorbar(mid_phase_bins, x_means, yerr=sj2s, fmt=\".\")\n    ax2.set_xlabel(\"Phase\")\n    ax2.set_ylabel(\"Flux\")\n\n    ax3 = fig.add_subplot(313)\n    ax3.plot(self.period_grid, gaussian([self.a, self.b, self.mu,\n                                         self.sigma], self.period_grid))\n    ax3.plot(self.period_grid, self.phis, \"k\")\n    ax3.set_xlabel(\"Period [days]\")\n    ax3.set_ylabel(\"Dispersion\")\n    ax3.axvline(self.pdm_period, color=\".5\", ls=\"--\")\n    ax3.axvline(self.mu, color=\"C0\", ls=\"--\")\n    ax3.axvline(self.mu - self.sigma, ls=\"--\", lw=.5)\n    ax3.axvline(self.mu + self.sigma, ls=\"--\", lw=.5)\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.pdm_rotation","title":"<code>pdm_rotation(period_grid, pdm_nbins=10)</code>","text":"<p>Calculate the optimum period from phase dispersion minimization.</p> <p>Parameters:</p> Name Type Description Default <code>period_grid</code> <code>array</code> <p>The period grid.</p> required <code>pdm_nbins</code> <code>array</code> <p>The number of bins to use when calculating phase dispersion.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>phis</code> <code>array</code> <p>The array of phi statistics</p> Source code in <code>starspot/starspot.py</code> <pre><code>def pdm_rotation(self, period_grid, pdm_nbins=10):\n\"\"\"\n    Calculate the optimum period from phase dispersion minimization.\n\n    Args:\n        period_grid (array): The period grid.\n        pdm_nbins (array): The number of bins to use when calculating phase\n            dispersion.\n\n    Returns:\n        phis (array): The array of phi statistics\n\n    \"\"\"\n    self.pdm_nbins = pdm_nbins\n    self.period_grid = period_grid\n\n    nperiods = len(period_grid)\n    phis = np.zeros(nperiods)\n    # for i, p in enumerate(period_grid):\n    for i in trange(len(period_grid)):\n        phis[i] = phi(pdm_nbins, period_grid[i], self.time, self.flux)\n\n    self.phis = phis\n\n    # Find period with the lowest Phi\n    ind = np.argmin(phis)\n    self.pdm_period = period_grid[ind]\n    if hasattr(self.pdm_period, 'len'):\n        self.pdm_period = self.pdm_period[0]\n\n    # Estimate the uncertainty\n    err, mu, a, b = estimate_uncertainty(period_grid, phis,\n                                           period_grid[ind])\n    self.sigma = err\n    self.mu = mu\n    self.a = a\n    self.b = b\n    self.period_err = err\n\n    # Calculate phase (for plotting)\n    phase = calc_phase(self.pdm_period, self.time)\n    self.phase = phase\n\n    return self.pdm_period, err\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.plot_posterior","title":"<code>plot_posterior(truth=None)</code>","text":"<p>Plot the posterior probability density function for rotation period.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def plot_posterior(self,truth=None):\n\"\"\"\n    Plot the posterior probability density function for rotation period.\n    \"\"\"\n    fig = plt.figure(figsize=(20, 5))\n    c= ChainConsumer()\n    c.add_chain([self.samples[key] for key in ['log_Q0', 'period', 'log_sigma', 'log_deltaQ', 'log_jitter', 'mean', 'mix']], \n    parameters=['log_Q0', 'period', 'log_sigma', 'log_deltaQ', 'log_jitter', 'mean', 'mix'], name = 'HMC only')\n    c.plotter.plot(truth=truth)\n    plt.show()\n    return fig\n</code></pre>"},{"location":"starspot_api/#starspot.RotationModel.plot_prediction","title":"<code>plot_prediction()</code>","text":"<p>Plot the GP prediction, fit to the data.</p> Source code in <code>starspot/starspot.py</code> <pre><code>def plot_prediction(self):\n\"\"\"\n    Plot the GP prediction, fit to the data.\n\n    \"\"\"\n    if not self.prediction:\n        print(\"You must run GP_rotate with prediction=True in order\" \\\n                \" to plot the prediction.\")\n        return\n\n    fig = plt.figure(figsize=(20, 5))\n    indices = np.random.choice(self.samples['pred'].shape[0],size=100,replace=False)\n\n    plt.errorbar(self.time,self.flux,yerr=self.flux_err,linestyle='none',marker='.',color='k')\n\n    for index in indices:\n        plt.plot(self.t_fine,self.samples['pred'][index,:],alpha=0.1,color='C0')\n    plt.xlabel(\"Time [days]\")\n    plt.ylabel(\"Relative flux\")\n    plt.xlim(self.t_fine.min(),self.t_fine.max())\n    return fig \n</code></pre>"},{"location":"utils_api/","title":"Documentation for <code>starspot</code> utils","text":""},{"location":"utils_api/#rotation_toolspy","title":"<code>rotation_tools.py</code>","text":"<p>Functions for manipulating stellar light curves.</p> <p>A set of functions for measuring rotation periods and plotting the results.</p>"},{"location":"utils_api/#starspot.rotation_tools.apply_masks","title":"<code>apply_masks(time, flux, flux_err, transit_masks)</code>","text":"<p>Apply transit masks to the unflattened light curve.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>array</code> <p>The time array.</p> required <code>flux</code> <code>array</code> <p>The flux array</p> required <code>flux_err</code> <code>array</code> <p>The flux_err array.</p> required <code>transit_masks</code> <code>list</code> <p>A list of transit masks.</p> required <p>Returns:</p> Name Type Description <code>masked_time</code> <code>array</code> <p>The masked time array.</p> <code>masked_flux</code> <code>array</code> <p>The masked flux array.</p> <code>masked_flux_err</code> <code>array</code> <p>The masked flux_err array.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def apply_masks(time, flux, flux_err, transit_masks):\n\"\"\"\n    Apply transit masks to the unflattened light curve.\n\n    Args:\n        time (array): The time array.\n        flux (array): The flux array\n        flux_err (array): The flux_err array.\n        transit_masks (list): A list of transit masks.\n\n    Returns:\n        masked_time (array): The masked time array.\n        masked_flux (array): The masked flux array.\n        masked_flux_err (array): The masked flux_err array.\n\n    \"\"\"\n    masked_time = time*1\n    masked_flux, masked_flux_err = flux*1, flux_err*1\n    for i in range(len(transit_masks)):\n        masked_time = masked_time[~transit_masks[i]]\n        masked_flux = masked_flux[~transit_masks[i]]\n        masked_flux_err = masked_flux_err[~transit_masks[i]]\n\n    return masked_time, masked_flux, masked_flux_err\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.butter_bandpass_filter","title":"<code>butter_bandpass_filter(flux, lowcut, fs, order=3)</code>","text":"<p>Apply a Butterworth high-pass filter.</p> <p>Parameters:</p> Name Type Description Default <code>flux</code> <code>array</code> <p>The flux array.</p> required <code>lowcut</code> <code>float</code> <p>The frequency cut off.</p> required <code>fs</code> <code>array</code> <p>The frequency array.</p> required <code>order</code> <code>Optional[int]</code> <p>The order of the Butterworth filter. Default is 3.</p> <code>3</code> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def butter_bandpass_filter(flux, lowcut, fs, order=3):\n\"\"\"\n    Apply a Butterworth high-pass filter.\n\n    Args:\n        flux (array): The flux array.\n        lowcut (float): The frequency cut off.\n        fs (array): The frequency array.\n        order (Optional[int]): The order of the Butterworth filter. Default\n            is 3.\n    \"\"\"\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    b, a = sps.butter(order, lowcut, btype='highpass')\n    y = sps.lfilter(b, a, flux)\n    return y\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.dan_acf","title":"<code>dan_acf(x, axis=0, fast=False)</code>","text":"<p>Estimate the autocorrelation function of a time series using the FFT.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The time series. If multidimensional, set the time axis using the <code>axis</code> keyword argument and the function will be computed for every other axis.</p> required <code>axis</code> <code>Optional[int]</code> <p>The time axis of <code>x</code>. Assumed to be the first axis if not specified.</p> <code>0</code> <code>fast</code> <code>Optional[bool]</code> <p>If <code>True</code>, only use the largest <code>2^n</code> entries for efficiency. (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>acf</code> <code>array</code> <p>The acf array.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def dan_acf(x, axis=0, fast=False):\n\"\"\"\n    Estimate the autocorrelation function of a time series using the FFT.\n\n    Args:\n        x (array): The time series. If multidimensional, set the time axis\n            using the ``axis`` keyword argument and the function will be\n            computed for every other axis.\n        axis (Optional[int]): The time axis of ``x``. Assumed to be the first\n            axis if not specified.\n        fast (Optional[bool]): If ``True``, only use the largest ``2^n``\n            entries for efficiency. (default: False)\n\n    Returns:\n        acf (array): The acf array.\n    \"\"\"\n    x = np.atleast_1d(x)\n    m = [slice(None), ] * len(x.shape)\n\n    # For computational efficiency, crop the chain to the largest power of\n    # two if requested.\n    if fast:\n        n = int(2**np.floor(np.log2(x.shape[axis])))\n        m[axis] = slice(0, n)\n        x = x\n    else:\n        n = x.shape[axis]\n\n    # Compute the FFT and then (from that) the auto-correlation function.\n    f = np.fft.fft(x-np.mean(x, axis=axis), n=2*n, axis=axis)\n    m[axis] = slice(0, n)\n    acf = np.fft.ifft(f * np.conjugate(f), axis=axis)[tuple(m)].real\n    m[axis] = 0\n    return acf / acf[m]\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.filter_sigma_clip","title":"<code>filter_sigma_clip(x, y, nsigma=3, window_length=49, polyorder=3)</code>","text":"<p>Sigma clip a light curve using a Savitzky-Golay filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The x-data array.</p> required <code>y</code> <code>array</code> <p>The y-data array.</p> required <code>nsigma</code> <code>Optional[float]</code> <p>The number of sigma to clip on.</p> <code>3</code> <code>window_length</code> <code>Optional[float]</code> <p>The filter window length.</p> <code>49</code> <code>polyorder</code> <code>Optional[float]</code> <p>The polynomial order of the filter.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>smooth</code> <code>array</code> <p>The smoothed data array.</p> <code>mask</code> <code>array</code> <p>The mask used for clipping.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def filter_sigma_clip(x, y, nsigma=3, window_length=49, polyorder=3):\n\"\"\" Sigma clip a light curve using a Savitzky-Golay filter.\n\n    Args:\n        x (array): The x-data array.\n        y (array): The y-data array.\n        nsigma (Optional[float]): The number of sigma to clip on.\n        window_length (Optional[float]): The filter window length.\n        polyorder (Optional[float]): The polynomial order of the filter.\n\n    Returns:\n        smooth (array): The smoothed data array.\n        mask (array): The mask used for clipping.\n\n    \"\"\"\n\n    # Smooth the data with a Savitsky-Golay filter.\n    smooth = sps.savgol_filter(y, window_length, polyorder)\n    resids = y - smooth\n\n    # Clip\n    mask = sigma_clip(resids, nsigma=nsigma)\n    return smooth, mask\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.find_and_mask_transits","title":"<code>find_and_mask_transits(time, flux, flux_err, periods, durations, nplanets=1, plot=False)</code>","text":"<p>Iteratively find and mask transits in the flattened light curve.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>array</code> <p>The time array.</p> required <code>flux</code> <code>array</code> <p>The flux array. You'll get the best results if this is flattened.</p> required <code>flux_err</code> <code>array</code> <p>The array of flux uncertainties.</p> required <code>periods</code> <code>array</code> <p>The array of periods to search over for BLS. For example, periods = np.linspace(0.5, 20, 10)</p> required <code>durations</code> <code>array</code> <p>The array of durations to search over for BLS. For example, durations = np.linspace(0.05, 0.2, 10)</p> required <code>nplanets</code> <code>Optional[int]</code> <p>The number of planets you'd like to search for. This function will interatively find and remove nplanets. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>transit_masks</code> <code>list</code> <p>a list of masks that correspond to the in transit points of each light curve. To mask out transits do time[~transit_masks[index]], etc.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def find_and_mask_transits(time, flux, flux_err, periods, durations,\n                           nplanets=1, plot=False):\n\"\"\"\n    Iteratively find and mask transits in the flattened light curve.\n\n    Args:\n        time (array): The time array.\n        flux (array): The flux array. You'll get the best results\n            if this is flattened.\n        flux_err (array): The array of flux uncertainties.\n        periods (array): The array of periods to search over for BLS.\n            For example, periods = np.linspace(0.5, 20, 10)\n        durations (array): The array of durations to search over for BLS.\n            For example, durations = np.linspace(0.05, 0.2, 10)\n        nplanets (Optional[int]): The number of planets you'd like to search for.\n            This function will interatively find and remove nplanets. Default is 1.\n\n    Returns:\n        transit_masks (list): a list of masks that correspond to the in\n            transit points of each light curve. To mask out transits do\n            time[~transit_masks[index]], etc.\n    \"\"\"\n\n    cum_transit = np.ones(len(time), dtype=bool)\n    _time, _flux, _flux_err = time*1, flux*1, flux_err*1\n\n    t0s, durs, porbs = [np.zeros(nplanets) for i in range(3)]\n    transit_masks = []\n    for i in range(nplanets):\n        bls = BoxLeastSquares(t=_time, y=_flux, dy=_flux_err)\n        bls.power(periods, durations)\n\n        periods = bls.autoperiod(durations, minimum_n_transit=3,\n                                 frequency_factor=5.0)\n        results = bls.autopower(durations, frequency_factor=5.0)\n\n        # Find the period of the peak\n        period = results.period[np.argmax(results.power)]\n\n        # Extract the parameters of the best-fit model\n        index = np.argmax(results.power)\n        porbs[i] = results.period[index]\n        t0s[i] = results.transit_time[index]\n        durs[i] = results.duration[index]\n\n        if plot:\n            # Plot the periodogram\n            fig, ax = plt.subplots(1, 1, figsize=(10, 5))\n            ax.plot(results.period, results.power, \"k\", lw=0.5)\n            ax.set_xlim(results.period.min(), results.period.max())\n            ax.set_xlabel(\"period [days]\")\n            ax.set_ylabel(\"log likelihood\")\n\n            # Highlight the harmonics of the peak period\n            ax.axvline(period, alpha=0.4, lw=4)\n            for n in range(2, 10):\n                ax.axvline(n*period, alpha=0.4, lw=1, linestyle=\"dashed\")\n                ax.axvline(period / n, alpha=0.4, lw=1, linestyle=\"dashed\")\n            # plt.show()\n\n            # plt.plot(_time, _flux, \".\")\n            # plt.xlim(1355, 1360)\n\n        in_transit = bls.transit_mask(_time, porbs[i], durs[i], t0s[i])\n        transit_masks.append(in_transit)\n        _time, _flux, _flux_err = _time[~in_transit], _flux[~in_transit], \\\n            _flux_err[~in_transit]\n\n    return transit_masks, t0s, durs, porbs\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.get_peak_statistics","title":"<code>get_peak_statistics(x, y, sort_by='height')</code>","text":"<p>Get the positions and height of peaks in an array.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>the x array (e.g. period or lag).</p> required <code>y</code> <code>array</code> <p>the y array (e.g. power or ACF).</p> required <code>sort_by</code> <code>str</code> <p>The way to sort the peak array. if \"height\", sort peaks in order of height, if \"position\", sort peaks in order of x-position.</p> <code>'height'</code> <p>Returns:</p> Name Type Description <code>x_peaks</code> <code>array</code> <p>the peak x-positions in descending height order, or ascending x-position order.</p> <code>y_peaks</code> <code>array</code> <p>the peak heights in descending height order, or ascending x-position order.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def get_peak_statistics(x, y, sort_by=\"height\"):\n\"\"\"\n    Get the positions and height of peaks in an array.\n\n    Args:\n        x (array): the x array (e.g. period or lag).\n        y (array): the y array (e.g. power or ACF).\n        sort_by (str): The way to sort the peak array. if \"height\", sort peaks\n            in order of height, if \"position\", sort peaks in order of\n            x-position.\n\n    Returns:\n        x_peaks (array): the peak x-positions in descending height order, or\n            ascending x-position order.\n        y_peaks (array): the peak heights in descending height order, or\n            ascending x-position order.\n    \"\"\"\n\n    # Array of peak indices\n    peaks = np.array([i for i in range(1, len(y)-1) if y[i-1] &lt;\n                      y[i] and y[i+1] &lt; y[i]])\n\n    # extract peak values\n    x_peaks = x[peaks]\n    y_peaks = y[peaks]\n\n    # sort by height\n    if sort_by == \"height\":\n        inds = np.argsort(y_peaks)\n        x_peaks, y_peaks = x_peaks[inds][::-1], y_peaks[inds][::-1]\n\n    # sort by position\n    elif sort_by == \"position\":\n        inds = np.argsort(x_peaks)\n        x_peaks, y_peaks = x_peaks[inds], y_peaks[inds]\n\n    return x_peaks, y_peaks\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.interp","title":"<code>interp(x_gaps, y_gaps, interval, interp_style='zero')</code>","text":"<p>Interpolate the light curve</p> <p>Parameters:</p> Name Type Description Default <code>x_gaps</code> <code>array</code> <p>The time array with gaps.</p> required <code>y_gaps</code> <code>array</code> <p>The flux array with gaps.</p> required <code>interval</code> <code>float</code> <p>The grid to interpolate to.</p> required <code>interp_style</code> <code>string</code> <p>The type of interpolation, e.g. \"zero\" or \"linear\". The default is \"zero\".</p> <code>'zero'</code> <p>Returns:</p> Name Type Description <code>time</code> <code>array</code> <p>The interpolated time array.</p> <code>flux</code> <code>array</code> <p>The interpolated flux array.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def interp(x_gaps, y_gaps, interval, interp_style=\"zero\"):\n\"\"\"\n    Interpolate the light curve\n\n    Args:\n        x_gaps (array): The time array with gaps.\n        y_gaps (array): The flux array with gaps.\n        interval (float): The grid to interpolate to.\n        interp_style (string): The type of interpolation, e.g. \"zero\" or\n            \"linear\". The default is \"zero\".\n\n    Returns:\n        time (array): The interpolated time array.\n        flux (array): The interpolated flux array.\n    \"\"\"\n    f = spi.interp1d(x_gaps, y_gaps, kind=interp_style)\n    x = np.arange(x_gaps[0], x_gaps[-1], interval)\n    return x, f(x)\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.load_and_normalize","title":"<code>load_and_normalize(fname)</code>","text":"<p>Load one quarter, remove bad points and median normalize it.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The path to and name of a light curve fits file.</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>array</code> <p>The time array.</p> <code>y</code> <code>array</code> <p>The flux array.</p> <code>y_err</code> <code>array</code> <p>The flux uncertainty array.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def load_and_normalize(fname):\n\"\"\"\n    Load one quarter, remove bad points and median normalize it.\n\n    Args:\n        fname (str): The path to and name of a light curve fits file.\n\n    Returns:\n        x (array): The time array.\n        y (array): The flux array.\n        y_err (array): The flux uncertainty array.\n    \"\"\"\n\n    # Load the data and pull out the time and flux arrays.\n    hdulist = fits.open(fname)\n    t = hdulist[1].data\n    time = t[\"TIME\"]\n    flux = t[\"PDCSAP_FLUX\"]\n    flux_err = t[\"PDCSAP_FLUX_ERR\"]\n    q = t[\"SAP_QUALITY\"]\n\n    # Mask out bad quality points and NaNs.\n    m = np.isfinite(time) * np.isfinite(flux) * np.isfinite(flux_err) * \\\n            (q == 0)\n    x = time[m]\n\n    # Median normalize\n    med = np.median(flux[m])\n    y = flux[m]/med - 1\n    yerr = flux_err[m]/med\n\n    return x, y, yerr\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.load_kepler_data","title":"<code>load_kepler_data(LC_DIR)</code>","text":"<p>Load data and join quarters together.</p> <p>Parameters:</p> Name Type Description Default <code>LC_DIR</code> <code>str</code> <p>The path to where the light curves are stored (will end in /.kplr/data/lightcurves/, where KID is a 9 digit number.) required <p>Returns:</p> Name Type Description <code>time</code> <code>array</code> <p>The time array.</p> <code>flux</code> <code>array</code> <p>The flux array.</p> <code>flux_err</code> <code>array</code> <p>The flux uncertainty array.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def load_kepler_data(LC_DIR):\n\"\"\"\n    Load data and join quarters together.\n\n    Args:\n        LC_DIR (str): The path to where the light curves are stored (will\n            end in /.kplr/data/lightcurves/&lt;KID&gt;, where KID is a 9 digit\n            number.)\n\n    Returns:\n        time (array): The time array.\n        flux (array): The flux array.\n        flux_err (array): The flux uncertainty array.\n    \"\"\"\n\n    # The names of the light curve fits files.\n    fnames = sorted(glob.glob(os.path.join(LC_DIR, \"*llc*fits\")))\n\n    # load and median normalize the first quarter\n    time, flux, flux_err = load_and_normalize(fnames[0])\n\n    # Concatenate with the remaining median normalized quarters\n    for fname in fnames[1:]:\n        x, y, yerr = load_and_normalize(fname)\n        time = np.concatenate((time, x))\n        flux = np.concatenate((flux, y))\n        flux_err = np.concatenate((flux_err, yerr))\n\n    return time, flux, flux_err\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.sigma_clip","title":"<code>sigma_clip(x, nsigma=3)</code>","text":"<p>Sigma clipping for 1D data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The data array. Assumed to be Gaussian in 1D.</p> required <code>nsigma</code> <code>float</code> <p>The number of sigma to clip on.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>newx</code> <code>array</code> <p>The clipped x array.</p> <code>mask</code> <code>array</code> <p>The mask used for clipping.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def sigma_clip(x, nsigma=3):\n\"\"\"\n    Sigma clipping for 1D data.\n\n    Args:\n        x (array): The data array. Assumed to be Gaussian in 1D.\n        nsigma (float): The number of sigma to clip on.\n\n    Returns:\n        newx (array): The clipped x array.\n        mask (array): The mask used for clipping.\n    \"\"\"\n\n    m = np.ones(len(x)) == 1\n    newx = x*1\n    oldm = np.array([False])\n    while sum(oldm) != sum(m):\n        oldm = m*1\n        sigma = np.std(newx)\n        m &amp;= np.abs(np.median(newx) - x)/sigma &lt; nsigma\n        newx = x[m]\n    return m\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.simple_acf","title":"<code>simple_acf(x_gaps, y_gaps, interval, smooth=9, window_length=99, polyorder=3, interp_style='zero')</code>","text":"<p>Compute an autocorrelation function and a period.</p> <p>Applies interpolation, smoothing and peak detection to estimate a rotation period.</p> <p>Parameters:</p> Name Type Description Default <code>x_gaps</code> <code>array</code> <p>The time array.</p> required <code>y_gaps</code> <code>array</code> <p>The flux array.</p> required <code>interval</code> <code>Optional[float]</code> <p>The time interval between successive observations. The default is Kepler cadence.</p> required <code>smooth</code> <code>Optional[float]</code> <p>The smoothing timescale.</p> <code>9</code> <code>window_length</code> <code>Optional[float]</code> <p>The filter window length.</p> <code>99</code> <code>polyorder</code> <code>Optional[float]</code> <p>The polynomial order of the filter.</p> <code>3</code> <code>interp_style</code> <code>string</code> <p>The type of interpolation, e.g. \"zero\" or \"linear\". The default is \"zero\".</p> <code>'zero'</code> <p>Returns:</p> Name Type Description <code>lags</code> <code>array</code> <p>The array of lag times in days.</p> <code>acf</code> <code>array</code> <p>The autocorrelation function.</p> <code>period</code> <code>float</code> <p>The period estimated from the highest peak in the ACF.</p> Source code in <code>starspot/rotation_tools.py</code> <pre><code>def simple_acf(x_gaps, y_gaps, interval, smooth=9, window_length=99,\n               polyorder=3, interp_style=\"zero\"):\n\"\"\"\n    Compute an autocorrelation function and a period.\n\n    Applies interpolation, smoothing and peak detection to estimate a\n    rotation period.\n\n    Args:\n        x_gaps (array): The time array.\n        y_gaps (array): The flux array.\n        interval (Optional[float]): The time interval between successive\n            observations. The default is Kepler cadence.\n        smooth (Optional[float]): The smoothing timescale.\n        window_length (Optional[float]): The filter window length.\n        polyorder (Optional[float]): The polynomial order of the filter.\n        interp_style (string): The type of interpolation, e.g. \"zero\" or\n            \"linear\". The default is \"zero\".\n\n    Returns:\n        lags (array): The array of lag times in days.\n        acf (array): The autocorrelation function.\n        period (float): The period estimated from the highest peak in the ACF.\n    \"\"\"\n\n    # First of all: interpolate to an evenly spaced grid\n    x, y = interp(x_gaps, y_gaps, interval, interp_style=interp_style)\n\n    # fit and subtract straight line\n    AT = np.vstack((x, np.ones_like(x)))\n    ATA = np.dot(AT, AT.T)\n    m, b = np.linalg.solve(ATA, np.dot(AT, y))\n    y -= m*x + b\n\n    # perform acf\n    acf = dan_acf(y)\n\n    # create 'lags' array\n    lags = np.arange(len(acf))*interval\n\n    # ditch the first point\n    acf, lags = acf[1:], lags[1:]\n\n    N = len(acf)\n    double_acf, double_lags = [np.zeros((2*N)) for i in range(2)]\n    double_acf[:N], double_lags[:N] = acf[::-1], -lags[::-1]\n    double_acf[N:], double_lags[N:] = acf, lags\n    acf, lags = double_acf, double_lags\n\n    # Smooth the data with a Savitsky-Golay filter.\n    acf_smooth = sps.savgol_filter(acf, window_length, polyorder)\n\n    # just use the second bit (no reflection)\n    acf_smooth, lags = acf_smooth[N:], lags[N:]\n\n    return lags, acf_smooth, x, y\n</code></pre>"},{"location":"utils_api/#starspot.rotation_tools.transit_mask","title":"<code>transit_mask(time, t0, duration, porb)</code>","text":"<p>Mask out transits</p> <p>Parameters:</p> Name Type Description Default <code>t0</code> <code>float</code> <p>The reference time of transit in days. For Kepler data you may need to subtract 2454833.0 off this number.</p> required <code>duration</code> <code>float</code> <p>The transit duration in days.</p> required <code>porb</code> <code>float</code> <p>The planet's orbital period in days.</p> required Source code in <code>starspot/rotation_tools.py</code> <pre><code>def transit_mask(time, t0, duration, porb):\n\"\"\"\n    Mask out transits\n\n    Args:\n        t0 (float): The reference time of transit in days.\n            For Kepler data you may need to subtract 2454833.0 off this\n            number.\n        duration (float): The transit duration in days.\n        porb (float): The planet's orbital period in days.\n\n    \"\"\"\n\n    dur = float(duration)\n    inv_mask = ((time - (t0 - .5*dur)) % porb) &lt; dur\n    mask = inv_mask == False\n    return mask\n</code></pre>"},{"location":"utils_api/#sigma_clippingpy","title":"<code>sigma_clipping.py</code>","text":"<p>Functions for sigma clipping. </p>"},{"location":"utils_api/#starspot.sigma_clipping.filter_sigma_clip","title":"<code>filter_sigma_clip(x, y, nsigma=3, window_length=49, polyorder=3)</code>","text":"<p>Sigma clip a light curve using a Savitzky-Golay filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The x-data array.</p> required <code>y</code> <code>array</code> <p>The y-data array.</p> required <code>nsigma</code> <code>Optional[float]</code> <p>The number of sigma to clip on. Default = 3.</p> <code>3</code> <code>window_length</code> <code>Optional[float]</code> <p>The filter window length. Must be an odd number. Default = 49.</p> <code>49</code> <code>polyorder</code> <code>Optional[float]</code> <p>The polynomial order of the filter. Default = 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>smooth</code> <code>array</code> <p>The smoothed data array.</p> <code>mask</code> <code>array</code> <p>The mask used for clipping.</p> Source code in <code>starspot/sigma_clipping.py</code> <pre><code>def filter_sigma_clip(x, y, nsigma=3, window_length=49, polyorder=3):\n\"\"\" Sigma clip a light curve using a Savitzky-Golay filter.\n\n    Args:\n        x (array): The x-data array.\n        y (array): The y-data array.\n        nsigma (Optional[float]): The number of sigma to clip on.\n            Default = 3.\n        window_length (Optional[float]): The filter window length.\n            Must be an odd number. Default = 49.\n        polyorder (Optional[float]): The polynomial order of the filter.\n            Default = 3.\n\n    Returns:\n        smooth (array): The smoothed data array.\n        mask (array): The mask used for clipping.\n\n    \"\"\"\n\n    # Smooth the data with a Savitsky-Golay filter.\n    smooth = sps.savgol_filter(y, window_length, polyorder)\n    resids = y - smooth\n\n    # Clip\n    mask = sigma_clip(resids, nsigma=nsigma)\n    return mask, smooth\n</code></pre>"},{"location":"utils_api/#starspot.sigma_clipping.sigma_clip","title":"<code>sigma_clip(x, nsigma=3)</code>","text":"<p>Sigma clipping for 1D data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The data array. Assumed to be Gaussian in 1D.</p> required <code>nsigma</code> <code>float</code> <p>The number of sigma to clip on.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>newx</code> <code>array</code> <p>The clipped x array.</p> <code>mask</code> <code>array</code> <p>The mask used for clipping.</p> Source code in <code>starspot/sigma_clipping.py</code> <pre><code>def sigma_clip(x, nsigma=3):\n\"\"\"\n    Sigma clipping for 1D data.\n\n    Args:\n        x (array): The data array. Assumed to be Gaussian in 1D.\n        nsigma (float): The number of sigma to clip on.\n\n    Returns:\n        newx (array): The clipped x array.\n        mask (array): The mask used for clipping.\n    \"\"\"\n\n    m = np.ones(len(x)) == 1\n    newx = x*1\n    oldm = np.array([False])\n    while sum(oldm) != sum(m):\n        oldm = m*1\n        sigma = np.std(newx)\n        m &amp;= np.abs(np.median(newx) - x)/sigma &lt; nsigma\n        newx = x[m]\n    return m\n</code></pre>"},{"location":"utils_api/#phase_dispersion_minimizationpy","title":"<code>phase_dispersion_minimization.py</code>","text":"<p>Functions for the phase dispersion minimization period estimator.</p> <p>Phase dispersion minimisation algorithm, Stellingwerf (1978).</p>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.calc_phase","title":"<code>calc_phase(p, t)</code>","text":"<p>Calculate the phase array.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>array</code> <p>The time array (in days).</p> required <code>p</code> <code>float</code> <p>Period (in days)</p> required <p>Returns     phase (array): The phase array.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def calc_phase(p, t):\n\"\"\"\n    Calculate the phase array.\n\n    Args:\n        t (array): The time array (in days).\n        p (float): Period (in days)\n\n    Returns\n        phase (array): The phase array.\n    \"\"\"\n\n    return (t % p)/p\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.estimate_uncertainty","title":"<code>estimate_uncertainty(period_grid, phi, best_period)</code>","text":"<p>Fit a Gaussian to the phase dispersion trough around the minimum and report the sigma.</p> <p>Parameters:</p> Name Type Description Default <code>period_grid</code> <code>array</code> <p>The period grid.</p> required <code>phi</code> <code>array</code> <p>The phase dispersions over periods.</p> required <p>Returns:</p> Type Description <p>mu, sigma (float): The mean and standard deviation of the Gaussian</p> <p>fit.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def estimate_uncertainty(period_grid, phi, best_period):\n\"\"\"\n    Fit a Gaussian to the phase dispersion trough around the minimum and\n    report the sigma.\n\n    Args:\n        period_grid (array): The period grid.\n        phi (array): The phase dispersions over periods.\n\n    Returns:\n        mu, sigma (float): The mean and standard deviation of the Gaussian\n        fit.\n\n    \"\"\"\n\n    # Peak finder\n    def peaks(y):\n        return np.array([i for i in range(1, len(y)-1) if y[i-1] &lt;\n                         y[i] and y[i+1] &lt; y[i]])\n\n    # limit to a section around the trough.\n    # Find peaks adjacent to the dip.\n    pks = peaks(phi)\n    peak_pos = period_grid[pks]\n    lower_peaks = peak_pos &lt; best_period\n    upper_peaks = peak_pos &gt; best_period\n\n    # Catch occasions where no adjacent peaks are found\n    if hasattr(peak_pos[lower_peaks], \"len\"):\n        lower_lim = peak_pos[lower_peaks][-1]\n    else:\n        lower_lim = min(period_grid)\n    if hasattr(peak_pos[upper_peaks], \"len\"):\n        upper_lim = peak_pos[upper_peaks][0]\n    else:\n        upper_lim = max(period_grid)\n\n    result, dip_x, dip_y = fit_gaussian(\n        period_grid, phi, upper_lim, lower_lim, best_period)\n\n    # If the uncertainty is close to 50%, the fit might have gone wrong:\n    # fit a Gaussian to a window that is a percentage of the period.\n    if result.x[-1]/best_period &gt; .4:\n        print(\"fitting to a limited range\")\n        upper_lim = best_period + .3*best_period\n        upper_lim = best_period - .3*best_period\n        result, dip_x, dip_y = fit_gaussian(\n            period_grid, phi, upper_lim, lower_lim, best_period)\n\n    a, b, mu, sigma = result.x\n\n    return sigma, mu, a, b\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.gaussian","title":"<code>gaussian(pars, x)</code>","text":"<p>A Gaussian, with a baseline of b.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def gaussian(pars, x):\n\"\"\"\n    A Gaussian, with a baseline of b.\n    \"\"\"\n    A, b, mu, sigma = pars\n    # return b + A/(np.sqrt(2*np.pi)*sigma**2) \\\n    return b + A \\\n        * np.exp(-.5*(x - mu)**2/sigma**2)\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.phase_bins","title":"<code>phase_bins(nbins, phase, x)</code>","text":"<p>Bin data by phase.</p> <p>Parameters:</p> Name Type Description Default <code>nbins</code> <code>int</code> <p>The number of bins.</p> required <code>phase</code> <code>float</code> <p>The phase array.</p> required <code>x</code> <code>array</code> <p>The flux array.</p> required <p>Returns     phase_bins (array): The phase bin edges (len = nbins + 1).     x_means (array): The mean flux in each bin.     Ns (array): The number of points in each bin.     per_bin_variances (array): The variance in each bin.     x_binned (list): A list of lists of flux. A list for each bin.     phase_binned (list): A list of lists of phases. A list for each bin.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def phase_bins(nbins, phase, x):\n\"\"\"\n    Bin data by phase.\n\n    Args:\n        nbins (int): The number of bins.\n        phase (float): The phase array.\n        x (array): The flux array.\n\n    Returns\n        phase_bins (array): The phase bin edges (len = nbins + 1).\n        x_means (array): The mean flux in each bin.\n        Ns (array): The number of points in each bin.\n        per_bin_variances (array): The variance in each bin.\n        x_binned (list): A list of lists of flux. A list for each bin.\n        phase_binned (list): A list of lists of phases. A list for each bin.\n\n    \"\"\"\n\n    min_phase, max_phase = 0, 1\n    phase_bins = np.linspace(min_phase, max_phase, nbins + 1)\n    x_binned, phase_binned = [], []\n    x_means, Ns, per_bin_variances = [np.empty(nbins) for i in range(3)]\n    for j in range(nbins):\n        m = (phase_bins[j] &lt; phase) * (phase &lt; phase_bins[j + 1])\n        Ns[j] = len(x[m])\n        x_means[j] = np.mean(x[m])\n        x_binned.append(x[m])\n        phase_binned.append(phase[m])\n        per_bin_variances[j] = sj2(x[m], x_means[j], Ns[j])\n\n    return x_means, phase_bins, \\\n        Ns, per_bin_variances, \\\n        x_binned, phase_binned\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.phi","title":"<code>phi(nbins, p, t, x)</code>","text":"<p>Calculate the phi statistic in Stellingwerf (1978).</p> <p>Parameters:</p> Name Type Description Default <code>nbins</code> <code>int</code> <p>The number of bins to use to calculate phase dispersion.</p> required <code>p</code> <code>float</code> <p>The period to calculate the Phi statistic for.</p> required <code>t</code> <code>array</code> <p>The time array.</p> required <code>x</code> <code>array</code> <p>The flux array.</p> required <p>Returns:</p> Name Type Description <code>phi</code> <code>float</code> <p>The phi statistic. Ratio of the phase-binned variance to</p> <p>the total variance.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def phi(nbins, p, t, x):\n\"\"\"\n    Calculate the phi statistic in Stellingwerf (1978).\n\n    Args:\n        nbins (int): The number of bins to use to calculate phase dispersion.\n        p (float): The period to calculate the Phi statistic for.\n        t (array): The time array.\n        x (array): The flux array.\n\n    Returns:\n        phi (float): The phi statistic. Ratio of the phase-binned variance to\n        the total variance.\n\n    \"\"\"\n\n    phase = calc_phase(p, t)\n    x_means, phase_bs, Ns, sj2s, xb, pb = phase_bins(nbins, phase, x)\n    total_binned_variance_s2 = s2(Ns, sj2s, nbins)\n    total_variance = sj2(x, np.mean(x), len(x))\n\n    return total_binned_variance_s2/total_variance\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.s2","title":"<code>s2(nj, sj2, M)</code>","text":"<p>Overall variance for the binned data. The s2 statistic (equation 2 of Stellingwerf, 1978).</p> <p>Parameters:</p> Name Type Description Default <code>nj</code> <code>array</code> <p>Number of data points per sample/bin (j = 1 to M).</p> required <code>sj2</code> <code>array</code> <p>Variance of each sample/bin (j = 1 to M).</p> required <code>M</code> <code>int</code> <p>Number of samples/bins.</p> required <p>Returns:</p> Type Description <p>The overall variance of the samples/bins.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def s2(nj, sj2, M):\n\"\"\"\n    Overall variance for the binned data. The s2 statistic (equation 2 of\n    Stellingwerf, 1978).\n\n    Args:\n        nj (array): Number of data points per sample/bin (j = 1 to M).\n        sj2 (array): Variance of each sample/bin (j = 1 to M).\n        M (int): Number of samples/bins.\n\n    Returns:\n        The overall variance of the samples/bins.\n\n    \"\"\"\n\n    return sum((nj - 1)*sj2)/(sum(nj) - M)\n</code></pre>"},{"location":"utils_api/#starspot.phase_dispersion_minimization.sj2","title":"<code>sj2(x, meanx, N)</code>","text":"<p>The variance of a set of data points in one bin.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>The flux array (defined as x in Stellingwerf, 1978).</p> required <code>meanx</code> <code>float</code> <p>The mean of x.</p> required <code>N</code> <code>int</code> <p>The number of data points</p> required <p>Returns:</p> Type Description <p>The variance of x.</p> Source code in <code>starspot/phase_dispersion_minimization.py</code> <pre><code>def sj2(x, meanx, N):\n\"\"\"\n    The variance of a set of data points in one bin.\n\n    Args:\n        x (array): The flux array (defined as x in Stellingwerf, 1978).\n        meanx (float): The mean of x.\n        N (int): The number of data points\n\n    Returns:\n        The variance of x.\n\n    \"\"\"\n\n    return sum((x - meanx)**2)/(N-1)\n</code></pre>"},{"location":"notebooks/tutorial/","title":"Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport starspot as ss\n\nimport numpyro\nnumpyro.set_host_device_count(2)\n\nimport jax\nimport jax.numpy as jnp\n\nimport numpyro\nimport numpyro.distributions as dist\nfrom numpyro.infer import MCMC, NUTS\n\nfrom tinygp import kernels, GaussianProcess\n\njax.config.update(\"jax_enable_x64\", True)\n</pre> import numpy as np import matplotlib.pyplot as plt  import starspot as ss  import numpyro numpyro.set_host_device_count(2)  import jax import jax.numpy as jnp  import numpyro import numpyro.distributions as dist from numpyro.infer import MCMC, NUTS  from tinygp import kernels, GaussianProcess  jax.config.update(\"jax_enable_x64\", True)  <pre>/Users/benjaminpope/opt/anaconda3/envs/starspot/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <p>In this tutorial, we will demonstrate how to use <code>starspot</code> to infer the rotation period of a simulated dataset.</p> In\u00a0[2]: Copied! <pre># Generate some data\ntime = np.linspace(0, 100, 1000)\nt = jnp.array(time, dtype=float)\nyerr = 0.01 * jnp.ones_like(t)\n</pre> # Generate some data time = np.linspace(0, 100, 1000) t = jnp.array(time, dtype=float) yerr = 0.01 * jnp.ones_like(t) <p>We are going to draw from a GP so we know the true parameters.</p> In\u00a0[3]: Copied! <pre>true_params = {\n    \"mean\": 0.0, # mean flux\n    \"log_jitter\": 2*jnp.log(jnp.min(yerr)), # jitter\n    \"log_sigma\": jnp.log(5), # variance\n    \"log_period\": jnp.log(10), # 2*pi/period\n    \"log_Q0\": 5., # quality factor\n    \"log_deltaQ\": 2.0, # 2.0\n    \"log_f\": 0.5, # mixture parameter,\n    \"mix\": 0.5\n}\n\ntrue_params['period'] = jnp.exp(true_params['log_period'])\n</pre>  true_params = {     \"mean\": 0.0, # mean flux     \"log_jitter\": 2*jnp.log(jnp.min(yerr)), # jitter     \"log_sigma\": jnp.log(5), # variance     \"log_period\": jnp.log(10), # 2*pi/period     \"log_Q0\": 5., # quality factor     \"log_deltaQ\": 2.0, # 2.0     \"log_f\": 0.5, # mixture parameter,     \"mix\": 0.5 }  true_params['period'] = jnp.exp(true_params['log_period']) In\u00a0[4]: Copied! <pre>gp = ss.build_gp(true_params,t,yerr)\n\nflux = gp.sample(jax.random.PRNGKey(12346))\nflux_err = jnp.sqrt(yerr**2 + jnp.exp(true_params[\"log_jitter\"]))\n\nplt.plot(t,flux)\nplt.xlim(t.min(), t.max())\n</pre>  gp = ss.build_gp(true_params,t,yerr)  flux = gp.sample(jax.random.PRNGKey(12346)) flux_err = jnp.sqrt(yerr**2 + jnp.exp(true_params[\"log_jitter\"]))  plt.plot(t,flux) plt.xlim(t.min(), t.max()) Out[4]: <pre>(0.0, 100.0)</pre> In\u00a0[5]: Copied! <pre>rotate = ss.RotationModel(time, flux, flux_err)\n</pre> rotate = ss.RotationModel(time, flux, flux_err)  In\u00a0[6]: Copied! <pre># Calculate the Lomb Scargle periodogram period (highest peak in the periodogram).\nlomb_scargle_period = rotate.ls_rotation()\nfig = rotate.ls_plot()\n</pre>  # Calculate the Lomb Scargle periodogram period (highest peak in the periodogram). lomb_scargle_period = rotate.ls_rotation() fig = rotate.ls_plot()  In\u00a0[7]: Copied! <pre># Calculate the autocorrelation function (ACF) period (highest peak in the ACF).\n# This is for evenly sampled data only -- time between observations is 'interval'.\nacf_period = rotate.acf_rotation(interval=np.diff(time)[0])\nfig = rotate.acf_plot\n</pre>  # Calculate the autocorrelation function (ACF) period (highest peak in the ACF). # This is for evenly sampled data only -- time between observations is 'interval'. acf_period = rotate.acf_rotation(interval=np.diff(time)[0]) fig = rotate.acf_plot In\u00a0[13]: Copied! <pre># Calculate the phase dispersion minimization period (period of lowest dispersion).\nperiod_grid = np.linspace(5, 20, 1000)\npdm_period, pdm_error = rotate.pdm_rotation(period_grid)\n\nprint('LS %.2f; ACF %.2f; PDM %.2f' % (lomb_scargle_period, acf_period, pdm_period))\n</pre> # Calculate the phase dispersion minimization period (period of lowest dispersion). period_grid = np.linspace(5, 20, 1000) pdm_period, pdm_error = rotate.pdm_rotation(period_grid)  print('LS %.2f; ACF %.2f; PDM %.2f' % (lomb_scargle_period, acf_period, pdm_period))  <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [01:49&lt;00:00,  9.13it/s]</pre> <pre>LS 10.02; ACF 10.11; PDM 9.94\n</pre> <pre>\n</pre> <p>So! The ACF, PDM, and LS periods work fine!</p> <p>Now let's fit a full Gaussian Process model to the light curve.</p> In\u00a0[9]: Copied! <pre># Calculate a Gaussian process rotation period - this is dominated by compile time\ngp_period = rotate.gp_rotation(init_period=lomb_scargle_period)\n</pre>  # Calculate a Gaussian process rotation period - this is dominated by compile time gp_period = rotate.gp_rotation(init_period=lomb_scargle_period) <pre>Sampling\n</pre> <pre>Running chain 0: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4000/4000 [07:43&lt;00:00,  8.63it/s] \nRunning chain 1: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4000/4000 [07:43&lt;00:00,  8.63it/s]\n</pre> <pre>GP Period: 9.953 + 0.039 - 0.036\n</pre> In\u00a0[10]: Copied! <pre>fig = rotate.plot_prediction()\n</pre> fig = rotate.plot_prediction() In\u00a0[11]: Copied! <pre>fig = rotate.plot_posterior(truth=true_params)\n</pre> fig = rotate.plot_posterior(truth=true_params) <pre>&lt;Figure size 2000x500 with 0 Axes&gt;</pre>"}]}